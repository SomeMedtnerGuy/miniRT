LIGHT:

-normal_at() (sphere)
# The important thing to first realize is that we can only find a normal of a point of an UNSTRANSFORMED sphere. So first we convert that point by applying to it the inverse of the current transformation of the sphere.
	object_p = M^-1 * world_p;
# Now we are able to find the normal by subtracting the resulting point by the origin. This way, we have a vector pointing from the origin to that point, which is perpendicular to it. Since we only care about direction, we normalize it and end up with the desired vector. (This operation effectively only turns the point to a vector by subtracting the w component and normalizes that!)
	object_normal = normalize(object_p - point(0));
# We found the normal to our untransformed sphere. Now we just have to apply the sphere's transformation to the normal. However, normals do not transform the same way as the rest of the vectors. If a sphere's y is scaled down, for example, the normal should turn in the opposite direction to keep its perpendicularity. This means that a different transform N will be applied to the normal instead. That N is t(M^-1). Here's why:
v is a vector across the surface.
n is the perpendicular vector.
M is the transformation of the object (therefore, of v, since it is linear).
N is the transformation of the normal, which we are trying to find out).
1. The dot product between a vector and a perpendicular one must be 0 (each coordinate cancels eachother out). Hence n•v = 0.
2. These vectors must remain perpendicular after transformation. Hence (N*n)*(M*v) = 0.
3. Manipulation using dot product/multiplication properties:
	t(N*n)•(M*v) = 0	(rule: x•y = t(x)•y)
	(t(n)*t(N))•(M*v) = 0	(rule: t(M*v) = t(v)*t(M))
	t(n)•(t(N)*M)*v = 0	(rule: v1*(v2*v3) = (v1*v2)*v3, same for Ms)
4. To be able to keep the statement n*v = 0, we cannot apply any transform to v. This means that t(N)*M must be the identity matrix. Hence, t(N)*M = I.
5. Continue manipulation:
	t(N)*M = I
	t(N) = M^-1	(Multiplying both sides by M^-1)
	N = t(M^-1)	(Transpose both sides. t(t(N)) is the same as N)
Conclusion: N, the transform that is to be applied to the normal to keep its perpendicularity to the transformed surface vector, must be t(M^-1).
	world_normal = t(M^-1) * object_normal;
# Finally, we say that the result is a vector and normalize it, since it is supposed to represent a normal
	world_normal.w = TVECTOR;
	return(normalize(world_normal));

-reflect()
# formula: r = in - normal*(2(in•normal))

